# -*- coding: utf-8 -*-
"""Final_Thesis_Code_Zecchin.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yXU-r49l7aI4H1NVI2EOmPyGcMCcX9vo
"""

import mrcfile
import numpy as np
import math
import finufft
import time
import matplotlib.pyplot as plt
from scipy import stats
import pickle

'''PARAMETERS SET BY USER'''
pdb_file = '1a3n.pdb'
voxel_size = 1 # A
k = 6
 
with open('Atomic_Info_dict.txt', 'rb') as handle:
    data = handle.read()
Atomic_Info_dict = pickle.loads(data)
with open('EASF_Paramters_dict.txt', 'rb') as handle:
    data = handle.read()
EASF_Paramters_dict = pickle.loads(data)

"""Fetch atom coordinates from PDB"""

def _find_atom_types(pdb_file):
    atoms = []
    with open(pdb_file) as fin:
        for line in fin:
            line = line.strip()
            if line[0:4] == "ATOM" or line[0:6] == "HETATM":
                atom_label = line[76:78].lstrip()
                if atom_label not in atoms:
                    atoms.append(atom_label)
    return atoms

def _append_atom(atomlist, atom_label, atom, pdb_line):
    atomlist.append([atom_label,
                     float(pdb_line[30:38].strip()),
                     float(pdb_line[38:46].strip()),
                     float(pdb_line[46:54].strip()),
                     atom])

def _get_atom_coords(pdb_file, scatt):
    tmp_atoms = []
    with open(pdb_file) as fin:
        for line in fin:
            line = line.strip()
            if line[0:4] == "ATOM" or line[0:6] == "HETATM":
                # occupany > 50 % || one of either if occupany = 50 %
                (occ, tag) = (float(line[56:60]), line[16])
                if (occ > 0.5) | ((occ == 0.5) & (tag != "B")):
                    atom_label = line[76:78].lstrip()
                    if atom_label in scatt:
                        _append_atom(tmp_atoms, atom_label, scatt[atom_label][0], line) 
                    else:
                        logstr = line[76:78] + " not in the current atom list"
                        logging.info(logstr)                    
    return np.asarray(tmp_atoms)

def _read_symmetry(pdb_file):
    sym_list = []
    trans_list = []
    with open(pdb_file) as fin:
        for line in fin:
            line = line.strip()
            if line[13:18] == "BIOMT":
                sym_list.append([float(line[24:33]), float(line[34:43]), float(line[44:53])])
                trans_list.append(float(line[58:68]))
    sym_arr = np.asarray(sym_list).reshape(-1, 3, 3)
    trans_arr = np.asarray(trans_list).reshape(-1, 3)
    return sym_arr, trans_arr

atoms_list = _find_atom_types(pdb_file)
atoms = _get_atom_coords(pdb_file, Atomic_Info_dict)
sym_arr, trans_arr = _read_symmetry(pdb_file)

"""Calculate Guassians of an atom's EASF function"""

def one_gaussian(a,b,distance):
    f = 2*np.pi*a*np.sqrt(np.pi/b)*np.exp(-(np.pi**2)*(distance**2)/b)
    return f
def five_gassians(string, distance):
    s = 0
    for i in np.arange(5):
        s += one_gaussian(EASF_Paramters_dict[string][i],EASF_Paramters_dict[string][5+i],distance)
    return s

"""Compute largest standard deviation of all Guassians of relevant atoms"""

def max_sd(atoms_list):
  big_sd = 0
  for i in atoms_list:
    for j in np.arange(5):
      a = EASF_Paramters_dict[i][j]
      b = EASF_Paramters_dict[i][5+j]
      sd_temp = np.sqrt(b/(2*np.pi*np.pi))
      if sd_temp > big_sd:
        big_sd = sd_temp
  return big_sd

"""Apply symmetry"""

atom_names = atoms[:,0] # names of the types of atoms
coords_Anum = np.array(atoms[:, 1:5],dtype=float) # convert from strings
atomic_nums = coords_Anum[:,3]
org_coords = coords_Anum[:,0:3]

def transform_coords(ORG_coords,SYM_arr,TRANS_arr):
  repeat = 0
  for i in np.arange(0,SYM_arr.shape[0]):
    if i == 0:
      coords = ORG_coords
      continue
    if (SYM_arr[i] == np.array([[1., 0., 0.],[0., 1., 0.],[0., 0., 1.]])).all():
      continue
    if TRANS_arr[i].shape == (3,):
      TRANS_arr[i].reshape(1,3)
    changed_coords = (ORG_coords @ SYM_arr[i] + TRANS_arr[i])
    coords = np.concatenate((coords, changed_coords), axis=0)
    repeat += 1
  return coords,repeat
coords, repeat = transform_coords(org_coords,sym_arr,trans_arr)

"""Create grid"""

for i in list(np.arange(repeat)):
  atom_names = np.concatenate([atoms[:,0],atom_names])

def molecule_details(atoms,atoms_list):
  total = 0
  for name in atoms_list:
    num = np.sum(atom_names == name)
    print(name,num)
    total+=num
  print('Total number of atoms:',total)
  return
molecule_details(atoms,atoms_list)

grid_len = np.abs(np.amax(coords,0) - np.amin(coords,0)).max()
q_max = k*2*np.pi # spatial frequency, inverse length

boundary = 3*max_sd(atoms_list) # length
sample_rate = np.pi / (1*q_max)
sample_voxel_num = math.floor(boundary/sample_rate)
q_max_resolution = 2*np.pi / voxel_size

coords += -coords.min() + (boundary)

grid_length = grid_len + 2*(boundary)

def compute_voxel_count(grid_length,voxel_size):
  voxel_count = math.ceil(grid_length/voxel_size)
  if voxel_count % 2 == 0:
    voxel_count += 1
  return voxel_count

voxel_count = compute_voxel_count(grid_length,voxel_size)

"""Compute NUFFT for each atom centered at 0"""

def create_3Dgrid(arr):
  x, y, z = np.meshgrid(arr, arr, arr, indexing='xy')
  return x,y,z

def distance_mat(x,y,z):
  return np.sqrt(np.square(x) + np.square(y) + np.square(z))

# Electron Density of all atoms
rescale = 2*np.pi/voxel_count
c_size = (voxel_count,voxel_count,voxel_count) # container size

# the sample points we are looking at
easf_base = np.arange(-(sample_voxel_num),sample_voxel_num+1, 1, dtype=int)
easf_base = easf_base * sample_rate 
kx, ky, kz = create_3Dgrid(easf_base)
dist_matrix = distance_mat(kx,ky,kz) # dist from origin
vc_half = voxel_count//2
r = np.arange(voxel_count) - vc_half
a1,a2,a3 = create_3Dgrid(r)

kx = kx[dist_matrix < boundary]
ky = ky[dist_matrix < boundary]
kz = kz[dist_matrix < boundary]

dist_matrix_filtered = dist_matrix[dist_matrix < boundary]

# convert the unit from A to voxel_size
kx0 = (kx/voxel_size) * rescale
ky0 = (ky/voxel_size) * rescale
kz0 = (kz/voxel_size) * rescale

fs_ed_dd = np.zeros(c_size,dtype=np.complex128) # empty matrix for Fourier Space ED
EASF_dict = {} # EASF evaluated in cube with side = 2*sample
EASF_radius_dict = {} # EASF evaluated in sphere with radius = 2*sample
NUFFT_dict = {} # NUFFT of the EASF within the sphere
FS_dict = {} # electron densities in Fourier Space

for name in atoms_list:
    EASF_dict[name] = five_gassians(name, dist_matrix)
    EASF_radius_dict[name] = five_gassians(name, dist_matrix)[dist_matrix < boundary].astype(np.complex128)
    f = (finufft.nufft3d1(kx0,ky0,kz0, EASF_radius_dict[name], c_size,isign=-1, eps=1e-15))
    NUFFT_dict[name] = f[a1 + vc_half, a2 + vc_half, a3 + vc_half]
    FS_dict[name] = np.zeros_like(fs_ed_dd)

"""NaÃ¯ve Method

"""

def naive_method():
  fs_ed_naive = np.zeros(c_size,dtype=np.complex128)
  for i in range(len(atom_names)):
    name = atom_names[i]
    x, y, z = coords[i,:]
    kx1 = kx + x
    ky1 = ky + y
    kz1 = kz + z
    kx1 /= voxel_size
    ky1 /= voxel_size
    kz1 /= voxel_size
    strengths = EASF_radius_dict[name]
    F_shifted = finufft.nufft3d1(kx1*rescale,ky1*rescale,kz1*rescale, strengths, c_size, isign=-1, eps=1e-15)
    fs_ed_naive += F_shifted[a1 + vc_half, a2 + vc_half, a3 + vc_half]
  return fs_ed_naive

fs_ed_naive = naive_method()

"""Phase Method"""

def compute_phase(val):
  phase = np.exp(-1j*val*rescale)
  return phase

def phase_method():
  fs_ed_phase = np.zeros(c_size,dtype=np.complex128)
  for i in np.arange(len(atom_names)):
    name = atom_names[i]
    atom_type = atom_names[i]
    x, y, z = coords[i,:]
    val = (x*a1 + y*a2 + z*a3)/voxel_size
    phase = compute_phase(val)
    fs_ed_phase += np.multiply(NUFFT_dict[atom_type],phase)
  return fs_ed_phase

fs_ed_phase = phase_method()

"""Dirac Delta Function Method"""

# number of nonuniform sample points
M = dist_matrix_filtered.shape[0]

# the nonuniform points
def random_points(length,scale,center):
  random_points = np.random.uniform(size=length)*scale - center
  return random_points

def dirac_delta():
  fs_ed_dd = np.zeros(c_size,dtype=np.complex128)
  for name in atoms_list:
    phase = 0
    c = np.zeros(M,dtype = np.complex128)
    positions = coords[np.where(atom_names == name),0:3][0]
    indices = positions[:,1].shape[0]
    xsub = random_points(M,voxel_count-1,vc_half)
    ysub = random_points(M,voxel_count-1,vc_half)
    zsub = random_points(M,voxel_count-1,vc_half)
    xsub[0:indices] = np.array(positions[:,0])
    ysub[0:indices] = np.array(positions[:,1])
    zsub[0:indices] = np.array(positions[:,2])
    x = (xsub/voxel_size*rescale) # rescale = 2*np.pi/voxel_count
    y = (ysub/voxel_size*rescale)
    z = (zsub/voxel_size*rescale)
    c[0:indices] = 1
    fdirac = finufft.nufft3d1(x,y,z, c, c_size,isign=-1, eps=1e-15)
    phase = fdirac[a1 + vc_half, a2 + vc_half, a3 + vc_half]
    fs_ed_dd += np.multiply(NUFFT_dict[name],phase)
    FS_dict[name] = np.multiply(NUFFT_dict[name],phase)  
  return fs_ed_dd

fs_ed_dd = dirac_delta()

"""Test if the electron densities from the phase method and dirac delta method are equal"""

def ed_compare(ed0,ed1,error):
  print(np.linalg.norm(ed0 - ed1)/np.linalg.norm(ed0))

"""Create MRC File for visualization of Electron Density"""

def transform_to_real_space(fs_ed):
  fs_ed_shifted = np.fft.ifftshift(fs_ed) # shift 0 frequency to corner
  rs_ed = np.fft.ifftn(fs_ed_shifted,s=c_size) # inverse transform from Fourier space to Real space
  #rs_ed = rs_ed[a1-vc_half//2, a2+vc_half, a3-vc_half//2] # for 1grl only
  rs_ed = np.real(rs_ed).astype(np.float32)
  return rs_ed

# create MRC File
def write_volume(vol, mapfile):
    vol = vol.astype(np.float32)
    with mrcfile.new(mapfile, overwrite=True) as m:
        m.set_data(vol)

with mrcfile.new('1grl.mrc',overwrite=True) as mrc:
     mrc.set_data(transform_to_real_space(fs_ed_dd))

"""Molmap Method

"""

def read_volume(mapfile):
    mrc = mrcfile.open(mapfile)
    vol = np.array(mrc.data)
    return vol

def mol_map_method(mrc_file):
  mrc0 = read_volume(mrc_file)
  mrc0_shape = mrc0.shape
  mrc_dim = max(mrc0_shape)
  if mrc_dim%2 == 0:
    mrc_dim += 1
  mrc = np.zeros([mrc_dim,mrc_dim,mrc_dim],dtype=np.complex128)
  mrc[:mrc0_shape[0],:mrc0_shape[1],:mrc0_shape[2]] = mrc0
  mrc_ed = np.fft.fftshift(np.fft.fftn(mrc))
  return mrc_ed

mrc_ed = mol_map_method("1a3nres6.mrc")

"""Radius of Gyration"""

# Center of Mass
def center_of_mass():
  c_sum = np.array([[0,0,0]],dtype=float)
  total_mass = 0
  for name in atoms_list:
    m = Atomic_Info_dict[name][1]
    positions = coords[np.where(atom_names == name),0:3] * m
    c_sum += np.sum(positions, axis = 1)
    total_mass += (m * positions.shape[1])
  return c_sum, total_mass

# Radius of Gyration
def radius_of_gyration():
  a_sum = 0
  c_sum, total_mass = center_of_mass()
  centers = (c_sum/total_mass)[0]
  for name in atoms_list:
    m = Atomic_Info_dict[name][1]
    positions = (coords[np.where(atom_names == name),0:3])[0]
    a_sum += np.sum(np.sum(((positions - centers)**2), axis = 1) * m)
  rg = np.sqrt(a_sum/total_mass)
  gs = -(rg**2)/3
  return rg, gs

rg,guinier_slope = radius_of_gyration()

print('Radius of Gyration :', rg)
print('slope :', guinier_slope)

"""Line of Best Fit Slopes"""

def better_cut(slope,ideal_slope,diff,r_value,best_r2):
  return ((np.abs(slope - ideal_slope) < diff) & ((r_value**2) >= 0.95))
  
def best_low_cutoff(x,y):
  best_r2, res_cut = 0,0
  plot_x, plot_y = [], []
  diff = np.inf
  ideal_slope = guinier_slope
  for cut in reversed(np.arange(2,len(x)+1)):
    rad = x[:cut]
    power = y[:cut]
    slope, intercept, r_value, _, _ = stats.linregress(rad, power)
    if better_cut(slope,ideal_slope,diff,r_value,best_r2):
      best_r2 = (r_value**2)
      diff = np.abs(slope - ideal_slope)
      res_cut = cut
      plot_x = rad
      plot_y = power
  slope,intercept = np.polyfit(plot_x, plot_y, 1)
  idx = np.abs(x - ((min(y)-intercept)/slope)).argmin()
  rad_double = x[:idx]
  line = intercept + slope * rad_double
  print('Low Frequency Line:\nSlope :',slope,'\nLow Intercept :',intercept)
  print('R Squared :',best_r2,'\n')
  plt.plot(rad_double, line, 'r')
  return

def best_high_cutoff(x,y):
  ideal_slope, best_r2, res_cut = 0,0,0
  plot_x, plot_y = [], []
  diff = np.inf
  for cut in reversed(np.arange(2,len(x)+1)):
    rad = x[-cut:]
    power = y[-cut:]
    slope, intercept, r_value, _, _ = stats.linregress(rad, power)
    if better_cut(slope,ideal_slope,diff,r_value,best_r2):
      best_r2 = (r_value**2)
      diff = np.abs(slope - ideal_slope)
      res_cut = cut
      plot_x = rad
      plot_y = power
  slope,intercept = np.polyfit(plot_x, plot_y, 1)
  idx = np.abs(x - (max(y)-intercept)/slope).argmin()
  rad_double = x[idx:]
  line = intercept + slope * rad_double
  print('High Frequency Line:\nSlope :',slope,'\nLow Intercept :',intercept)
  print('R Squared :',best_r2,'\n')
  plt.plot(rad_double, line, 'b')
  return

# Plotting the data points and the best fit line
def plot_power_spec(x,y):
  plt.figure(figsize=(12, 7))
  plt.scatter(x, y,color = 'black')
  best_low_cutoff(x,y)
  best_high_cutoff(x,y)
  plt.title('Power Spectrum')
  plt.xlabel('Spatial Frequency Squared (q^2)')
  plt.ylabel('Average Power (ln)')
  plt.show()

"""Power Spectrum Analysis"""

bin_size = 1

def bsz_round(x): # rounds down
  x = np.floor(x/bin_size)*bin_size
  return x

def power_spectrum(elec_dens,compare):
  #  if comparing powerspecs on one graph, compare = True. Ex: multiple atoms
  s = elec_dens.shape[0]
  r = np.arange(-(s//2),(s//2)+bin_size)
  x,y,z = create_3Dgrid(r)
  radii = distance_mat(x,y,z)

  ft2 = np.abs(elec_dens)**2
  rounded_radii = np.array((bsz_round(radii).ravel() / bin_size), dtype = int)
  r_count = np.zeros_like(r)
  ave_power = np.zeros_like(r)

  ft2 = ft2.ravel()
  rounded_radii = rounded_radii[ft2 != 0]
  ft2 = ft2[ft2 != 0]
  
  ave_power = np.bincount(rounded_radii, ft2.ravel())
  x = np.arange(len(ave_power)) * bin_size
  r_count = np.bincount(rounded_radii)
  y = ave_power/r_count
  x = x * q_max_resolution / x.max()
  x = x**2
  if compare: k = 1
  else: k = y[0]
  y = np.log(y/k)
  return x, y

"""Power Spectrum of Molmap"""

x, y = power_spectrum(mrc_ed,compare = False)
plot_power_spec(x,y)

"""Power Spectrum of Dirac Delta Function Method"""

x,y = power_spectrum(fs_ed_dd,compare = False)
plot_power_spec(x,y)

"""Power Spectrum by Atomic Breakdown of Dirac Delta Method"""

x,y,z = create_3Dgrid(r)
radii = distance_mat(x,y,z)

plt.figure(figsize=(15, 7))
for name in atoms_list:
  x,y = power_spectrum(FS_dict[name],True)
  plt.plot(x,y, label = name)

plt.title('Power Spectrum: Atom Breakdown')
plt.xlabel('Spatial Frequency Squared (q^2)')
plt.ylabel('Average Power (ln)')
plt.legend()
plt.show()

"""EASF in Real Space by Atomic Breakdown"""

interval = 0.1
x = np.arange(-8,8+interval,interval)

plt.figure(figsize=(15, 7))
for name in atoms_list:
  plt.plot(x,(five_gassians(name, x)), label = name)

plt.xlabel('Radius (A)')
plt.ylabel('Averaged value (log)')
plt.title('EASFs in Real Space of GroEL')
plt.legend()
plt.show()